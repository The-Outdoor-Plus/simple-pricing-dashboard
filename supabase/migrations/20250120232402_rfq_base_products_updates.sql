drop policy "Update RFQ Forms" on "public"."rfq";

drop policy "Enable users to view their own data only" on "public"."rfq";

create table "public"."emails" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone default now(),
    "html" text,
    "name" text,
    "type" text
);


alter table "public"."emails" enable row level security;

alter table "public"."BaseProducts" add column "fts_name_sku" tsvector generated always as (to_tsvector('english'::regconfig, ((((((((product || ' '::text) || base_part_number) || ' '::text) || feature_type) || ' '::text) || product_type) || ' '::text) || fire_feature_category))) stored;

alter table "public"."order" alter column "comments" set default '[]'::jsonb;

alter table "public"."order" alter column "updates" set default '[]'::jsonb;

alter table "public"."rfq" add column "estimate_signed" boolean default false;

alter table "public"."rfq" add column "invoice_payment_link" text;

alter table "public"."rfq" add column "private_notes" jsonb default '[]'::jsonb;

alter table "public"."rfq" alter column "updates" set default '[]'::jsonb;

CREATE INDEX base_products_fts_name_sku ON public."BaseProducts" USING gin (fts_name_sku);

CREATE UNIQUE INDEX emails_pkey ON public.emails USING btree (id);

alter table "public"."emails" add constraint "emails_pkey" PRIMARY KEY using index "emails_pkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.generate_product_variations()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    product_record RECORD;
    attribute_placeholders TEXT[];
    variation_data JSONB;
    sql TEXT;
    material_json JSONB; -- Store the JSONB object for the material
    attribute_combination RECORD;
    attribute_placeholder TEXT;
BEGIN
    -- Create a temporary table to store the variations
    DROP TABLE IF EXISTS temp_variations;
    CREATE TEMP TABLE temp_variations (
        base_product_id UUID,
        sku TEXT,
        price NUMERIC,
        name TEXT,
        material_name TEXT,
        attributes JSONB -- Store attributes as JSONB
    );

    -- Loop through each product in BaseProducts
    FOR product_record IN SELECT * FROM "BaseProducts"
    LOOP
        -- 1. Extract attribute placeholders from code_formula
        attribute_placeholders := ARRAY(SELECT DISTINCT substring(code_formula from '{([A-Z]+)}') FROM "BaseProducts" WHERE id = product_record.id);

        -- 2. & 3. Filter and Aggregate Attributes into a JSONB object
        SELECT
            jsonb_build_object(
                'MAT', (SELECT jsonb_agg(jsonb_build_object('code', ma.attribute_code, 'name', ma.attribute_option, 'add_on_price', ma.add_on_price)) 
                        FROM "MaterialsAttributes" ma 
                        WHERE ma.product_filter = product_record.product),
                'attributes', (SELECT jsonb_agg(jsonb_build_object('code', a.attribute_code, 'name', a.attribute_option, 'add_on_price', a.add_on_price, 'identifier', a.code_identifier))
                                FROM "Attributes" a
                                WHERE (product_record.product ILIKE ANY(string_to_array(REPLACE(a.product_filter, '"', ''), ',')) OR a.product_filter IS NULL)
                                AND (product_record.size ILIKE ANY(string_to_array(REPLACE(a.size_filter, '"', ''), ',')) OR a.size_filter IS NULL)
                                AND (product_record.feature_type ILIKE ANY(string_to_array(REPLACE(a.feature_filter, '"', ''), ',')) OR a.feature_filter IS NULL)
                                AND (product_record.fire_feature_category ILIKE ANY(string_to_array(REPLACE(a.feature_category_filter, '"', ''), ',')) OR a.feature_category_filter IS NULL)
                                AND a.code_identifier = ANY(attribute_placeholders)
                                )
            )
        INTO variation_data
        FROM "BaseProducts" bp
        WHERE bp.id = product_record.id;

        -- 4. Generate Variations (Dynamically construct SQL based on attribute_placeholders and variation_data)
        sql := 'INSERT INTO temp_variations (base_product_id, sku, price, name, material_name, attributes) VALUES ';
        
        -- Loop through materials
        FOR material_json IN SELECT jsonb_array_elements(variation_data -> 'MAT')
        LOOP
            -- Basic values using material only
            sql := sql || format('(%L, %L, %s, %L, %L, %L),',
                                product_record.id,
                                REPLACE(product_record.code_formula, '{MAT}', material_json ->> 'code'),
                                product_record.base_price_dealer + COALESCE((material_json ->> 'add_on_price')::NUMERIC, 0),
                                product_record.product || COALESCE(' - ' || (material_json ->> 'name'), ''),
                                material_json ->> 'name',
                                variation_data -> 'attributes'
                               );
        END LOOP;

        -- Loop through attribute combinations
        FOR attribute_combination IN SELECT * FROM jsonb_array_elements(variation_data -> 'attributes')
        LOOP
           -- Loop through materials again for each attribute combination
           FOR material_json IN SELECT jsonb_array_elements(variation_data -> 'MAT')
           LOOP
                -- Combine material with each attribute and calculate price
                DECLARE
                    current_sku TEXT;
                    current_price NUMERIC;
                    current_name TEXT;
                BEGIN
                     current_sku := product_record.code_formula;
                    -- Replace {MAT} placeholder
                    current_sku := REPLACE(current_sku, '{MAT}', material_json ->> 'code');

                    -- Replace other attribute placeholders
                    FOREACH attribute_placeholder IN ARRAY attribute_placeholders
                    LOOP
                        IF attribute_placeholder <> 'MAT' THEN
                            current_sku := REPLACE(current_sku, '{' || attribute_placeholder || '}', attribute_combination ->> 'code');
                        END IF;
                    END LOOP;

                    current_price := product_record.base_price_dealer + 
                                     COALESCE((material_json ->> 'add_on_price')::NUMERIC, 0) +
                                     COALESCE((attribute_combination ->> 'add_on_price')::NUMERIC, 0);

                    current_name := product_record.product || ' - ' || 
                                    (material_json ->> 'name') || ' - ' ||
                                    (attribute_combination ->> 'name');
                
                    sql := sql || format('(%L, %L, %s, %L, %L, %L),',
                                        product_record.id,
                                        current_sku,
                                        current_price,
                                        current_name,
                                        material_json ->> 'name',
                                        variation_data -> 'attributes'
                                       );
                END;
            END LOOP;
        END LOOP;

        -- Remove the last comma
        sql := LEFT(sql, length(sql) - 1);

        -- Execute the dynamically generated SQL to insert variations
        EXECUTE sql;

    END LOOP;

    -- Create or replace the materialized view
    CREATE MATERIALIZED VIEW IF NOT EXISTS product_variations AS
    SELECT * FROM temp_variations;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.search_product_by_name_sku(term text)
 RETURNS TABLE(id uuid, base_part_number text, product text, base_price_dealer numeric, code_formula text, product_shape text, specification_sheet text, size text, feature_type text, fire_feature_category text)
 LANGUAGE plpgsql
AS $function$
begin
  return query
  select bp.id, bp.base_part_number, bp.product, bp.base_price_dealer, bp.code_formula, bp.product_shape, bp.specification_sheet, bp.size, bp.feature_type, bp.fire_feature_category
  from public."BaseProducts" bp
  where bp.fts_name_sku @@ to_tsquery(term || ':*');
end;
$function$
;

grant delete on table "public"."emails" to "anon";

grant insert on table "public"."emails" to "anon";

grant references on table "public"."emails" to "anon";

grant select on table "public"."emails" to "anon";

grant trigger on table "public"."emails" to "anon";

grant truncate on table "public"."emails" to "anon";

grant update on table "public"."emails" to "anon";

grant delete on table "public"."emails" to "authenticated";

grant insert on table "public"."emails" to "authenticated";

grant references on table "public"."emails" to "authenticated";

grant select on table "public"."emails" to "authenticated";

grant trigger on table "public"."emails" to "authenticated";

grant truncate on table "public"."emails" to "authenticated";

grant update on table "public"."emails" to "authenticated";

grant delete on table "public"."emails" to "service_role";

grant insert on table "public"."emails" to "service_role";

grant references on table "public"."emails" to "service_role";

grant select on table "public"."emails" to "service_role";

grant trigger on table "public"."emails" to "service_role";

grant truncate on table "public"."emails" to "service_role";

grant update on table "public"."emails" to "service_role";

create policy "Allow Admins to Delete"
on "public"."emails"
as permissive
for delete
to authenticated
using (check_user_role(auth.uid(), 'ADMIN'::user_role));


create policy "Allow Admins to Insert"
on "public"."emails"
as permissive
for insert
to authenticated
with check (check_user_role(auth.uid(), 'ADMIN'::user_role));


create policy "Allow Admins to Update"
on "public"."emails"
as permissive
for update
to authenticated
using (check_user_role(auth.uid(), 'ADMIN'::user_role))
with check (check_user_role(auth.uid(), 'ADMIN'::user_role));


create policy "Allow Select to Authenticated"
on "public"."emails"
as permissive
for select
to authenticated
using (true);


create policy "Allow Actions on Enums"
on "public"."enums"
as permissive
for all
to authenticated
using (true);


create policy "Update RFQ"
on "public"."rfq"
as permissive
for update
to authenticated
using ((check_user_role(auth.uid(), 'ADMIN'::user_role) OR (( SELECT auth.uid() AS uid) = user_id) OR (EXISTS ( SELECT 1
   FROM (users u
     JOIN "Company" c ON ((u.company = c.id)))
  WHERE ((u.id = auth.uid()) AND (u.role = 'SALES'::user_role) AND ((rfq.company_id = c.id) OR (rfq.company_id IN ( SELECT "Company".id
           FROM "Company"
          WHERE ("Company".parent_company = c.id))))))) OR (EXISTS ( SELECT 1
   FROM (users u
     JOIN "Company" c ON ((u.company = c.id)))
  WHERE ((u.id = auth.uid()) AND (u.role = 'SALES'::user_role) AND (c.name = 'The Outdoor Plus'::text))))));


create policy "Enable users to view their own data only"
on "public"."rfq"
as permissive
for select
to authenticated
using ((check_user_role(auth.uid(), 'ADMIN'::user_role) OR (( SELECT auth.uid() AS uid) = user_id) OR (EXISTS ( SELECT 1
   FROM (users u
     JOIN "Company" c ON ((u.company = c.id)))
  WHERE ((u.id = auth.uid()) AND (u.role = 'SALES'::user_role) AND ((rfq.company_id = c.id) OR (rfq.company_id IN ( SELECT "Company".id
           FROM "Company"
          WHERE ("Company".parent_company = c.id))))))) OR (EXISTS ( SELECT 1
   FROM (users u
     JOIN "Company" c ON ((u.company = c.id)))
  WHERE ((u.id = auth.uid()) AND (u.role = 'SALES'::user_role) AND (c.name = 'The Outdoor Plus'::text))))));



